<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring使用RestTemplate]]></title>
    <url>%2F2017%2F06%2F13%2Fspring%E4%BD%BF%E7%94%A8RestTemplate%2F</url>
    <content type="text"><![CDATA[restFul一种软件架构风格，设计风格而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 最近在使用RestTemplate访问restful资源，在使用spring cloud 微服务之间的调用，服务消费者调用服务提供者的方法。 RestTemplate restTemplate = new RestTemplate(); 有四种方式去请求restful资源 GET方法get方法有返回值 123456789101112131415161718192021222324//第一种参数拼接（在服务端用request获取参数，不用在路径拼接）//客户端（消费者）String message = restTemplate.getForObject("http://localhost:8080/hemsWisProdInstService/yourTestService?name=zhaoshijie&amp;id=80", String.class );//服务端（提供者）@RequestMapping("/hemsWisProdInstService")public class HemsWisProdInstService &#123; @RequestMapping(value="/yourTestService",method=RequestMethod.GET) public String insertTspDeviceOpporInvokeLog()&#123; HttpServletRequest request = new HttpServletRequest(); String name = request.getParameter("name"); String name = request.getParameter("id"); &#125;//-----------------------------------------------------------------------------------------------------------------//第二种参数拼接//客户端String message = restTemplate.getForObject("http://localhost:8080/hemsWisProdInstService/yourTestService/zhaoshijie/80", String.class );//服务端@RequestMapping("/hemsWisProdInstService")public class HemsWisProdInstService &#123; @RequestMapping(value="/yourTestService/&#123;name&#125;/&#123;id&#125;",method=RequestMethod.GET) public String insertTspDeviceOpporInvokeLog(@Pathvariable String name,@Pathvariable String id )&#123; String name = name; String name = id; &#125; PUT方法put方法没有返回值 1234//客户端restTemplate.put("http://" + dboraclePath + "/tspDeviceOpporDbService/tspOpporDbDealed/?opporId=" + opporId+"&amp;dealFlag="+dealFlag+ "&amp;traceId=" + traceId + "&amp;spanId=" + startLog.getSpanId(), null);//服务端参考GET方法 POTS方法post方法有返回值 123456789101112131415//客户端（消费者）//使用MAP传递参数 Map&lt;String ,Object&gt; urlVariables = new HashMap&lt;String ,Object&gt;(); urlVariables.put("name", "zhaoshijie"); urlVariables.put("id", 80); String message3 = restTemplate.postForObject("http://localhost:8080/hemsWisProdInstService/yourTestService",null, String.class, urlVariables);//服务端接收Map的参数（提供者）@RequestMapping("/hemsWisProdInstService")public class HemsWisProdInstService &#123; @RequestMapping(value="/yourTestService",method=RequestMethod.POST) public String insertTspDeviceOpporInvokeLog(@RequestParam Map&lt;String,Object&gt; map)&#123; String name = name; String name = id; &#125; DELETE方法delete方法（注意：delete方法没有返回值，说明，id=0这个参数在服务器端可以不定义该参数，直接使用request获取） 123//客户端restTemplate.delete("http://localhost:8080/yongbarservice/appstore/appgoods/deleteranking?id=0"); //服务端参考GET方法]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>restFul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们为什么要用docker(转载)]]></title>
    <url>%2F2017%2F06%2F06%2F%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8docker%2F</url>
    <content type="text"><![CDATA[​ 有业务开发、测试、运维经历的同学可能会有所共鸣，像测试环境调试、线上资源扩容等工作往往会成为系统上线的最后一道坎，甚至说是最难缠的噩梦也不为过。作为开发经常会想，我代码写的没问题呀，为啥发到测试环境全是错，甚至连系统都启动不了。测试同学面对错综复杂的环境问题，同样也会束手无策，各种环境、hosts等交叉起来就像蜘蛛网一样剪不断理还乱。对于运维同学估计也是不堪其扰，环境有一点问题，估计都会找到运维同学这边来，运维也不得不安排1,2个人，甚至是更多人员来专门处理这种环境问题。环境问题就像一个紧箍咒戴在开发、测试、运维的头上，严重制约着技术人员的生产力。有没有银弹可以解决这个问题呢？我想，或许有，如果有的话那就将会是docker。之前研究消息队列来解决服务之间异步处理问题，接下来研究spring cloud来解决架构问题并封装了容器，当然这两个部分还有更深入研究的价值，不过这不是本文讨论的重点。本文的重点将在docker上，利用docker可以做到封装环境，来彻底解决测试环境以及系统扩容等问题。这样可以做到带着环境一起交付，将开发、测试和运维同学从环境调试中彻底解放出来。​ docker是一种轻量级容器管理引擎，和虚拟机不同的是，虚拟机虚拟运行于硬件之上，而docker运行在操作系统内核上的用户空间中。由于这个原因，docker只能运行与宿主机相类似的操作系统，不过这往往不是一个问题，实际中很少有需求需要虚拟不同的操作系统。得益于现代linux内核的一些特性，如cgroup、命名空间等，docker和宿主机以及不同的docker实例之间的隔离也可以做到比较彻底，每个docker实例都会有独立的网络和存储栈，还有独立的资源管理能力，这使得同一台宿主机中的不同docker实例都可以友好共存。​ docker的设计目标就是要加强开发人员写代码的开发环境和应用程序部署的测试环境以及在线环境的一致性，降低“开发一切正常，部署就出问题”这一风险。docker改变了咱们传统代码交付的概念，现在开发人员完成开发工作实际上交付的是代码，这里边最大的问题其实就是执行环境的问题，这使得技术人员不得不花大量精力来解决环境而导致代码执行出现的各种问题。而依赖的执行环境是无法控制的，不能标准化的。而Docker可以将代码和其执行的环境绑定在一起，以镜像形式交付。让开发完成的代码在标准的容器中，在标准的环境下执行。个人感觉这是革命性的一个改进，将大大改进现有的开发-&gt;测试-&gt;上线流程。相信无论是开发人员、测试人员还是运维人员都会爱上它，通过发布完成的镜像，与其他服务集成，使得开发流程自动化。在服务部署方面，无需再对配置进行变更，所谓的发布就是销毁这个服务并重建一个，而由于这样的操作，使得线上扩容也不再是一个问题。使用docker线上扩容则几乎不需要测试，因为每次扩容的过程就是发布时进行的操作。​ 在现有的技术栈中引入docker是一项挑战性的工作，这需要开发、运维、测试等技术人员的共同推动以及转换现有的工作思路。但越艰难的事情越值得去做，收获也会越大。我想我们准备好了，那么就从现在开始吧~ 如果侵权，请联系DaMiss删除]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC注解详解（转载）]]></title>
    <url>%2F2017%2F06%2F05%2FspringMVC%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@Controlller在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 @Controller 用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器。单单使用@Controller 标记在一个类上还不能真正意义上的说它就是SpringMVC 的一个控制器类，因为这个时候Spring 还不认识它。那么要如何做Spring 才能认识它呢？这个时候就需要我们把这个控制器类交给Spring 来管理。有两种方式： （1）在SpringMVC 的配置文件中定义MyController 的bean 对象。 （2）在SpringMVC 的配置文件中告诉Spring 该到哪里去找标记为@Controller 的Controller 控制器。 1234&lt;!--方式一--&gt;&lt;bean class="com.host.app.web.controller.MyController"/&gt;&lt;!--方式二--&gt;&lt; context:component-scan base-package = "com.host.app.web" /&gt;//路径写到controller的上一层(扫描包详解见下面浅析) @RequestMappingRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 RequestMapping注解有六个属性，下面我们把她分成三类进行说明（下面有相应示例）。 value， methodvalue： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）； method： 指定请求的method类型， GET、POST、PUT、DELETE等； consumes，producesconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； params，headersparams： 指定request中必须包含某些参数值是，才让该方法处理。 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。 @Resource和@Autowired@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。 共同点两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。 不同点@Autowired@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。 12345678910public class TestServiceImpl &#123; // 下面两种@Autowired只要使用一种即可 @Autowired private UserDao userDao; // 用于字段上 @Autowired public void setUserDao(UserDao userDao) &#123; // 用于属性的方法上 this.userDao = userDao; &#125;&#125; @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下 12345public class TestServiceImpl &#123; @Autowired @Qualifier("userDao") private UserDao userDao; &#125; @Resource@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。 12345678910public class TestServiceImpl &#123; // 下面两种@Resource只要使用一种即可 @Resource(name="userDao") private UserDao userDao; // 用于字段上 @Resource(name="userDao") public void setUserDao(UserDao userDao) &#123; // 用于属性的setter方法上 this.userDao = userDao; &#125;&#125; 注：最好是将@Resource放在setter方法上，因为这样更符合面向对象的思想，通过set、get去操作属性，而不是直接去操作属性。 @Resource装配顺序： ①如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。 ②如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。 ③如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。 ④如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。 @Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。 @ModelAttribute和 @SessionAttributes代表的是：该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特性，应用在BaseController当中，所有的Controller继承BaseController，即可实现在调用Controller时，先执行@ModelAttribute方法。 @SessionAttributes即将值放到session作用域中，写在class上面。 具体示例参见下面：使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据 @PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如： 123456789101112131415161718192021@Controller public class TestController &#123; @RequestMapping(value="/user/&#123;userId&#125;/roles/&#123;roleId&#125;",method = RequestMethod.GET) public String getLogin(@PathVariable("userId") String userId, @PathVariable("roleId") String roleId)&#123; System.out.println("User Id : " + userId); System.out.println("Role Id : " + roleId); return "hello"; &#125; @RequestMapping(value="/product/&#123;productId&#125;",method = RequestMethod.GET) public String getProduct(@PathVariable("productId") String productId)&#123; System.out.println("Product Id : " + productId); return "hello"; &#125; @RequestMapping(value="/javabeat/&#123;regexp1:[a-z-]+&#125;", method = RequestMethod.GET) public String getRegExp(@PathVariable("regexp1") String regexp1)&#123; System.out.println("URI Part 1 : " + regexp1); return "hello"; &#125; &#125; @requestParam@requestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue 表示设置默认值，required 铜过boolean设置是否是必须要传入的参数，value 值表示接受的传入的参数类型。 @ResponseBody作用： 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @Component相当于通用的注解，当不知道一些类归到哪个层时使用，但是不建议。 @Repository用于注解dao层，在daoImpl类上面注解。 注意使用 @RequestMapping 来映射 Request 请求与处理器方式一、通过常见的类路径和方法路径结合访问controller方法 方式二、使用uri模板 123456789101112@Controller@RequestMapping ( "/test/&#123;variable1&#125;" )public class MyController &#123; @RequestMapping ( "/showView/&#123;variable2&#125;" ) public ModelAndView showView( @PathVariable String variable1, @PathVariable ( "variable2" ) int variable2) &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName( "viewName" ); modelAndView.addObject( " 需要放到 model 中的属性名称 " , " 对应的属性值，它是一个对象 " ); return modelAndView; &#125;&#125; URI 模板就是在URI 中给定一个变量，然后在映射的时候动态的给该变量赋值。如URI 模板http://localhost/app/{variable1}/index.html ，这个模板里面包含一个变量variable1 ，那么当我们请求http://localhost/app/hello/index.html 的时候，该URL 就跟模板相匹配，只是把模板中的variable1 用hello 来取代。这个变量在SpringMVC 中是使用@PathVariable 来标记的。在SpringMVC 中，我们可以使用@PathVariable 来标记一个Controller 的处理方法参数，表示该参数的值将使用URI 模板中对应的变量的值来赋值。 代码中我们定义了两个URI 变量，一个是控制器类上的variable1 ，一个是showView 方法上的variable2 ，然后在showView 方法的参数里面使用@PathVariable 标记使用了这两个变量。所以当我们使用/test/hello/showView/2.do 来请求的时候就可以访问到MyController 的showView 方法，这个时候variable1 就被赋予值hello ，variable2 就被赋予值2 ，然后我们在showView 方法参数里面标注了参数variable1 和variable2 是来自访问路径的path 变量，这样方法参数variable1 和variable2 就被分别赋予hello 和2 。方法参数variable1 是定义为String 类型，variable2 是定义为int 类型，像这种简单类型在进行赋值的时候Spring 是会帮我们自动转换的。 在上面的代码中我们可以看到在标记variable1 为path 变量的时候我们使用的是@PathVariable ，而在标记variable2 的时候使用的是@PathVariable(“variable2”) 。这两者有什么区别呢？第一种情况就默认去URI 模板中找跟参数名相同的变量，但是这种情况只有在使用debug 模式进行编译的时候才可以，而第二种情况是明确规定使用的就是URI 模板中的variable2 变量。当不是使用debug 模式进行编译，或者是所需要使用的变量名跟参数名不相同的时候，就要使用第二种方式明确指出使用的是URI 模板中的哪个变量。 除了在请求路径中使用URI 模板，定义变量之外，@RequestMapping 中还支持通配符“* ”。如下面的代码我就可以使用/myTest/whatever/wildcard.do 访问到Controller 的testWildcard 方法。如： 123456789@Controller@RequestMapping ( "/myTest" )public class MyController &#123; @RequestMapping ( "*/wildcard" ) public String testWildcard() &#123; System. out .println( "wildcard------------" ); return "wildcard" ; &#125; &#125; 当@PathVariable中没有指定参数名称时，Spring 在代码是debug 编译的情况下会默认取更方法参数同名的参数，如果不是debug 编译的就会报错。 使用 @RequestMapping 的一些高级用法params属性12345@RequestMapping (value= "testParams" , params=&#123; "param1=value1" , "param2" , "!param3" &#125;) public String testParams() &#123; System. out .println( "test Params..........." ); return "testParams" ; &#125; 用@RequestMapping 的params 属性指定了三个参数，这些参数都是针对请求参数而言的，它们分别表示参数param1 的值必须等于value1 ，参数param2 必须存在，值无所谓，参数param3 必须不存在，只有当请求/testParams.do 并且满足指定的三个参数条件的时候才能访问到该方法。所以当请求/testParams.do?param1=value1&amp;param2=value2 的时候能够正确访问到该testParams 方法，当请求/testParams.do?param1=value1&amp;param2=value2&amp;param3=value3 的时候就不能够正常的访问到该方法，因为在@RequestMapping 的params 参数里面指定了参数param3 是不能存在的。 method属性1234@RequestMapping (value= "testMethod" , method=&#123;RequestMethod. GET , RequestMethod. DELETE &#125;) public String testMethod() &#123; return "method" ; &#125; 在上面的代码中就使用method 参数限制了以GET 或DELETE 方法请求/testMethod 的时候才能访问到该Controller 的testMethod 方法。 headers属性1234@RequestMapping (value= "testHeaders" , headers=&#123; "host=localhost" , "Accept" &#125;) public String testHeaders() &#123; return "headers" ; &#125; headers 属性的用法和功能与params 属性相似。在上面的代码中当请求/testHeaders.do 的时候只有当请求头包含Accept 信息，且请求的host 为localhost 的时候才能正确的访问到testHeaders 方法。 @RequestMapping 标记的处理器方法支持的方法参数和返回类型支持的方法参数类型 （1 ）HttpServlet 对象，主要包括HttpServletRequest 、HttpServletResponse 和HttpSession 对象。 这些参数Spring 在调用处理器方法的时候会自动给它们赋值，所以当在处理器方法中需要使用到这些对象的时候，可以直接在方法上给定一个方法参数的申明，然后在方法体里面直接用就可以了。但是有一点需要注意的是在使用HttpSession 对象的时候，如果此时HttpSession 对象还没有建立起来的话就会有问题。 （2 ）Spring 自己的WebRequest 对象。 使用该对象可以访问到存放在HttpServletRequest 和HttpSession 中的属性值。 （3 ）InputStream 、OutputStream 、Reader 和Writer 。 InputStream 和Reader 是针对HttpServletRequest 而言的，可以从里面取数据；OutputStream 和Writer 是针对HttpServletResponse 而言的，可以往里面写数据。 （4 ）使用@PathVariable 、@RequestParam 、@CookieValue 和@RequestHeader 标记的参数。 （5 ）使用@ModelAttribute 标记的参数。 （6 ）java.util.Map 、Spring 封装的Model 和ModelMap 。 **这些都可以用来封装模型数据，用来给视图做展示。 （7 ）实体类。 可以用来接收上传的参数。 （ 8 ）Spring 封装的MultipartFile 。用来接收上传文件的。 （9 ）Spring 封装的Errors 和BindingResult 对象。 这两个对象参数必须紧接在需要验证的实体对象参数之后，它里面包含了实体对象的验证结果。 支持的返回类型（1 ）一个包含模型和视图的ModelAndView 对象。 （2 ）一个模型对象，这主要包括Spring 封装好的Model 和ModelMap ，以及java.util.Map ，当没有视图返回的时候视图名称将由RequestToViewNameTranslator 来决定。 （3 ）一个View 对象。这个时候如果在渲染视图的过程中模型的话就可以给处理器方法定义一个模型参数，然后在方法体里面往模型中添加值。 （4 ）一个String 字符串。这往往代表的是一个视图名称。这个时候如果需要在渲染视图的过程中需要模型的话就可以给处理器方法一个模型参数，然后在方法体里面往模型中添加值就可以了。 （5 ）返回值是void 。这种情况一般是我们直接把返回结果写到HttpServletResponse 中了，如果没有写的话，那么Spring 将会利用RequestToViewNameTranslator 来返回一个对应的视图名称。如果视图中需要模型的话，处理方法与返回字符串的情况相同。 （6 ）如果处理器方法被注解@ResponseBody 标记的话，那么处理器方法的任何返回类型都会通过HttpMessageConverters 转换之后写到HttpServletResponse 中，而不会像上面的那些情况一样当做视图或者模型来处理。 （7 ）除以上几种情况之外的其他任何返回类型都会被当做模型中的一个属性来处理，而返回的视图还是由RequestToViewNameTranslator 来决定，添加到模型中的属性名称可以在该方法上用@ModelAttribute(“attributeName”) 来定义，否则将使用返回类型的类名称的首字母小写形式来表示。使用@ModelAttribute 标记的方法会在@RequestMapping 标记的方法执行之前执行。 使用 @ModelAttribute 和 @SessionAttributes 传递和保存数据SpringMVC 支持使用 @ModelAttribute 和 @SessionAttributes 在不同的模型（model）和控制器之间共享数据。 @ModelAttribute 主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。 当 @ModelAttribute 标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在 session 或模型属性中，属性名称可以使用 @ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。关于 @ModelAttribute 标记在方法上时对应的属性是存放在 session 中还是存放在模型中，我们来做一个实验，看下面一段代码。 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping ( "/myTest" )public class MyController &#123; @ModelAttribute ( "hello" ) public String getModel() &#123; System. out .println( "-------------Hello---------" ); return "world" ; &#125; @ModelAttribute ( "intValue" ) public int getInteger() &#123; System. out .println( "-------------intValue---------------" ); return 10; &#125; @RequestMapping ( "sayHello" ) public void sayHello( @ModelAttribute ( "hello" ) String hello, @ModelAttribute ( "intValue" ) int num, @ModelAttribute ( "user2" ) User user, Writer writer, HttpSession session) throws IOException &#123; writer.write( "Hello " + hello + " , Hello " + user.getUsername() + num); writer.write( "\r" ); Enumeration enume = session.getAttributeNames(); while (enume.hasMoreElements()) writer.write(enume.nextElement() + "\r" ); &#125; @ModelAttribute ( "user2" ) public User getUser()&#123; System. out .println( "---------getUser-------------" ); return new User(3, "user2" ); &#125;&#125; 当我们请求 /myTest/sayHello.do 的时候使用 @ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello 方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示： Hello world,Hello user210* ​ 由执行结果我们可以看出来，此时 session 中没有包含任何属性，也就是说上面的那些对象都是存放在模型属性中，而不是存放在 session 属性中。那要如何才能存放在 session 属性中呢？这个时候我们先引入一个新的概念 @SessionAttributes ，它的用法会在讲完 @ModelAttribute 之后介绍，这里我们就先拿来用一下。我们在 MyController 类上加上 @SessionAttributes 属性标记哪些是需要存放到 session 中的。看下面的代码： 1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping ( "/myTest" )@SessionAttributes (value=&#123; "intValue" , "stringValue" &#125;, types=&#123;User. class &#125;)public class MyController &#123; @ModelAttribute ( "hello" ) public String getModel() &#123; System. out .println( "-------------Hello---------" ); return "world" ; &#125; @ModelAttribute ( "intValue" ) public int getInteger() &#123; System. out .println( "-------------intValue---------------" ); return 10; &#125; @RequestMapping ( "sayHello" ) public void sayHello(Map&lt;String, Object&gt; map, @ModelAttribute ( "hello" ) String hello, @ModelAttribute ( "intValue" ) int num, @ModelAttribute ( "user2" ) User user, Writer writer, HttpServletRequest request) throws IOException &#123; map.put( "stringValue" , "String" ); writer.write( "Hello " + hello + " , Hello " + user.getUsername() + num); writer.write( "\r" ); HttpSession session = request.getSession(); Enumeration enume = session.getAttributeNames(); while (enume.hasMoreElements()) writer.write(enume.nextElement() + "\r" ); System. out .println(session); &#125; @ModelAttribute ( "user2" ) public User getUser() &#123; System. out .println( "---------getUser-------------" ); return new User(3, "user2" ); &#125;&#125; 在上面代码中我们指定了属性为 intValue 或 stringValue 或者类型为 User 的都会放到 Session中，利用上面的代码当我们访问 /myTest/sayHello.do 的时候，结果如下： Hello world,Hello user210* 仍然没有打印出任何 session 属性，这是怎么回事呢？怎么定义了把模型中属性名为 intValue 的对象和类型为 User 的对象存到 session 中，而实际上没有加进去呢？难道我们错啦？我们当然没有错，只是在第一次访问 /myTest/sayHello.do 的时候 @SessionAttributes 定义了需要存放到 session 中的属性，而且这个模型中也有对应的属性，但是这个时候还没有加到 session 中，所以 session 中不会有任何属性，等处理器方法执行完成后 Spring 才会把模型中对应的属性添加到 session 中。所以当请求第二次的时候就会出现如下结果： Hello world,Hello user210* user2 intValue stringValue 当 @ModelAttribute 标记在处理器方法参数上的时候，表示该参数的值将从模型或者 Session 中取对应名称的属性值，该名称可以通过 @ModelAttribute(“attributeName”) 来指定，若未指定，则使用参数类型的类名称（首字母小写）作为属性名称。 @PathVariable和@RequestParam的区别请求路径上有个id的变量值，可以通过@PathVariable来获取 @RequestMapping(value = “/page/{id}”, method = RequestMethod.GET)@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。 简介：handler method 参数绑定常用的注解,我们根据他们处理的Request的不同内容部分分为四类：（主要讲解常用类型） A、处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解： @PathVariable; B、处理request header部分的注解： @RequestHeader, @CookieValue; C、处理request body部分的注解：@RequestParam, @RequestBody; D、处理attribute类型是注解： @SessionAttributes, @ModelAttribute; （1）、@PathVariable当使用@RequestMapping URI template 样式映射时， 即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上。 示例代码： 123456789@Controller @RequestMapping("/owners/&#123;ownerId&#125;") public class RelativePathUriTemplateController &#123; @RequestMapping("/pets/&#123;petId&#125;") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125; &#125; 上面代码把URI template 中变量 ownerId的值和petId的值，绑定到方法的参数上。若方法参数名称和需要绑定的uri template中变量名称不一致，需要在@PathVariable(“name”)指定uri template中的名称。 （2）、 @RequestHeader、@CookieValue@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。 示例代码： 这是一个Request 的header部分： Host localhost:8080 Accept text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300 @RequestMapping(“/displayHeaderInfo.do”) public void displayHeaderInfo(@RequestHeader(“Accept-Encoding”) String encoding, ​ @RequestHeader(“Keep-Alive”) long keepAlive) { } 上面的代码，把request header部分的 Accept-Encoding的值，绑定到参数encoding上了， Keep-Alive header的值绑定到参数keepAlive上。 @CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。 例如有如下Cookie值： JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 123@RequestMapping("/displayHeaderInfo.do") public void displayHeaderInfo(@CookieValue("JSESSIONID") String cookie) &#123; &#125; 即把JSESSIONID的值绑定到参数cookie上。 （3）、@RequestParam, @RequestBody@RequestParam A） 常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值； B）用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST； C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定； 示例代码： 1234567891011@Controller @RequestMapping("/pets") @SessionAttributes("pet") public class EditPetForm &#123; @RequestMapping(method = RequestMethod.GET) public String setupForm(@RequestParam("petId") int petId, ModelMap model) &#123; Pet pet = this.clinic.loadPet(petId); model.addAttribute("pet", pet); return "petForm"; &#125;&#125; @RequestBody 该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； 它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; 示例代码： 1234@RequestMapping(value = "/something", method = RequestMethod.PUT) public void handle(@RequestBody String body, Writer writer) throws IOException &#123; writer.write(body); &#125; （4）、@SessionAttributes, @ModelAttribute@SessionAttributes: 该注解用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。 该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象； 示例代码： 123456@Controller @RequestMapping("/editPet.do") @SessionAttributes("pet") public class EditPetForm &#123; // ... &#125; @ModelAttribute 该注解有两个用法，一个是用于方法上，一个是用于参数上； 用于方法上时： 通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model； 用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于： A） @SessionAttributes 启用的attribute 对象上； B） @ModelAttribute 用于方法上时指定的model对象； C） 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。 用到方法上@ModelAttribute的示例代码： 1234@ModelAttribute public Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number); &#125; 这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）。 用在参数上的@ModelAttribute示例代码： 1234@RequestMapping(value="/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit", method = RequestMethod.POST) public String processSubmit(@ModelAttribute Pet pet) &#123; &#125; 首先查询 @SessionAttributes有无绑定的Pet对象，若没有则查询@ModelAttribute方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。 6、&lt; context:component-scan base-package = “” /&gt;浅析component-scan 默认扫描的注解类型是 @Component，不过，在 @Component 语义基础上细化后的 @Repository, @Service 和 @Controller 也同样可以获得 component-scan 的青睐 有了，另一个标签根本可以移除掉，因为已经被包含进去了 另外还提供了两个子标签 //指定扫描的路径 //排除扫描的路径 有一个use-default-filters属性，属性默认为true,表示会扫描指定包下的全部的标有@Component的类，并注册成bean.也就是@Component的子注解@Service,@Reposity等。 这种扫描的粒度有点太大，如果你只想扫描指定包下面的Controller或其他内容则设置use-default-filters属性为false，表示不再按照scan指定的包扫描，而是按照指定的包扫描，示例： 123&lt;context:component-scan base-package="com.tan" use-default-filters="false"&gt; &lt;context:include-filter type="regex" expression="com.tan.*"/&gt;//注意后面要写.*&lt;/context:component-scan&gt; 当没有设置use-default-filters属性或者属性为true时，表示基于base-packge包下指定扫描的具体路径 12345&lt;context:component-scan base-package="com.tan" &gt; &lt;context:include-filter type="regex" expression=".controller.*"/&gt; &lt;context:include-filter type="regex" expression=".service.*"/&gt; &lt;context:include-filter type="regex" expression=".dao.*"/&gt;&lt;/context:component-scan&gt; 效果相当于： 123&lt;context:component-scan base-package="com.tan" &gt; &lt;context:exclude-filter type="regex" expression=".model.*"/&gt;&lt;/context:component-scan&gt; 注意：本人尝试时无论哪种情况和都不能同时存在]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService之CXF开发]]></title>
    <url>%2F2017%2F06%2F01%2FWebService%E4%B9%8BCXF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言 Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序从表面上看，Web service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法通过Web来调用这个应用程序。我们把调用这个Web service 的应用程序叫做客户。WebService解决的问题：远程调用，跨平台调用，跨语言调用。 CXF和Axis2都是使用Java编写的WebService技术，不管是使用什么语言编写的webservice都要遵循SOAP协议（简单对象访问协议）， Webservice主要就是两部分组成：SOAP和XML代码片段。 这里DaMiss就说一下CXF的具体实现过程（服务端和客户端） 服务端开发导入jar包导入jar包的时候可以使用maven依赖，前提你这个服务端的开发使用的是maven项目构建工具。 在web.xml里面配置CXF的组件也就是拦截请求，请求哪个路径是使用的webservice技术 12345678&lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 定义服务端的终端接口和它的实现类接口定义【注意】接口定义类上面必须要加标签注释@WebService，在接口方法上面加标签注释@WebMethod 1234567891011@WebServicepublic interface HelloWS &#123; @WebMethod String sayHello(String name); @WebMethod List&lt;User&gt; getUserLists(Boolean flag); @WebMethod Map&lt;Integer,User&gt; getUserMaps();&#125; 接口实现类【注意】指定命名空间targetNamespace（这里的命名空间和自己的包名是有关系的，命名空间采用域名倒置的原则），和服务名字serviceName，指定服务名字的作用是为了在客户端调用的时候，规范代码。 1234@WebService(targetNamespace=Constants.NAMESPACE,serviceName="HelloWSFactory")public class HelloWSImpl implements HelloWS &#123; ..........此处省略实现接口的方法&#125; 发布服务发布服务的有两种方式：①与spring集成②main方法启动方式（web工程是不会用的） 与spring集成发布定义applicationContext-ws.xml文件，文件内容如下 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:lang="http://www.springframework.org/schema/lang" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt;&lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-extension-soap.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt;&lt;!--这里利用bean的配置引入我们的接口实现类 --&gt; &lt;bean id="helloWS" class="com.markie.ws.sei.impl.HelloWSImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt;&lt;!-- 这里的adress就是我们发布的地址，我们在网页上输入网址http：localhost：8080/工程名字/webservice/sayHello?wsdl即可 --&gt; &lt;jaxws:endpoint implementor="#helloWS" address="/sayHello"&gt; &lt;jaxws:inInterceptors&gt; &lt;!-- 系统拦截器 --&gt; &lt;bean class="org.apache.cxf.interceptor.LoggingInInterceptor"/&gt; &lt;!-- 自定义拦截器 --&gt;&lt;!-- &lt;bean class="com.markie.ws.interceptor.CheckUserInterceptor"/&gt; --&gt; &lt;/jaxws:inInterceptors&gt; &lt;jaxws:outInterceptors&gt; &lt;bean class="org.apache.cxf.interceptor.LoggingOutInterceptor"/&gt; &lt;/jaxws:outInterceptors&gt;&lt;/jaxws:endpoint&gt;&lt;/beans&gt; 【注意】上面的步骤当中，我只是写了一个接口服务。那么当存在多个接口 的时候，应该怎么做呢？有两种方式供选择。 第一种：两个的服务名个命名空间是一样的，在spring的配置文件里面，分别给这两个接口的实现类加入发布路径，在生成XML文件 的时候分别输入自己的发布路径来获得自己的文件。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:lang="http://www.springframework.org/schema/lang" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt;&lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-extension-soap.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt;&lt;bean id="helloWS" class="com.markie.ws.sei.impl.HelloWSImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt;&lt;bean id="saygoodWS" class="com.markie.ws.sei.impl.SayGoodByeImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt; &lt;jaxws:server id="sayhelloService" serviceClass="com.markie.ws.sei.impl.HelloWSImpl" address="/sayHello" &gt; &lt;jaxws:serviceBean&gt; &lt;ref bean="helloWS" /&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt; &lt;jaxws:server id="saygoodservice" serviceClass="com.markie.ws.sei.impl.SayGoodByeImpl" address="/sayGoodByeWS" &gt; &lt;jaxws:serviceBean&gt; &lt;ref bean="saygoodWS" /&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt; &lt;/beans&gt; 第二种：写一个公共的服务接口，其他的在内部service实现，但是在服务端就要告诉客户端有哪些服务名字了。 （我这里先不写具体的步骤了，还没弄多懂） main方法发布 main方法启动（定义发布的网址可以随便写，但是网址后面必须带有在web.xml里面拦截的路径请求字眼，比如我们现在拦截的是/webservice/*，发布成功之后，在网页输入发布网址http://localhost:9999/CXF_Server/webservice/sayHello?wsdl(注意在发布的网址后面追加?wsdl)，即可访问生成的XML代码，这些xml代码片段就是描述了服务端的接口详细信息，是一个XMl文件） 12345678910111213public class PublicServerTest &#123; public static void main(String[] args) &#123; Endpoint endpoint = Endpoint.publish("http://localhost:9999/CXF_Server/webservice/sayHello", new HelloWSImpl()); EndpointImpl endpointImpl = (EndpointImpl) endpoint; List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = endpointImpl.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); //inInterceptors.add(new CheckUserInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = endpointImpl.getOutInterceptors(); outInterceptors.add(new LoggingOutInterceptor()); System.out.println("发布WS服务成功！"); &#125;&#125; 客户端开发下载CXF版本，配置环境变量项目中导入jar包，可以使用maven依赖操作我们在客户端访问发布路径生成的XML文件，这里有两种方式。第一种采用CXF指令，首先建立一个文件切换到此文件夹下面，在终端输入wsdl2java 发布路径？wsdl 即可。也可以把我们访问路径生成的文件拷贝下来，放在新建的文件夹下面（同样执行命令之前要切换到此新建的目录下面），保存在一个后缀名为 .wsdl的文件里面 再在终端输入命令wsdl2java XXX.wsdl即可。执行命令之后会相应的执行命令的文件夹下产生一些一系列的代码，我们把这些代码拷贝都我们的客户工程的一个文件夹下即可。 导入生成的代码之后的应用： 12345678910111213141516171819202122232425262728@Test public void testHello() &#123; //反向生成,通过生成客户端代码实现 URL url = null; //这里的HelloWSFactory 就是我们在服务端生成的XML文件里面的服务名字描述，可以研究一下里面的内容，然后通过getHelloWSImplPort（）方法就可以的到我们的服务端的实现类的对象。就可以使用里面的方法了。 HelloWSFactory helloWSFactory = new HelloWSFactory(url); HelloWS helloWS = helloWSFactory.getHelloWSImplPort(); Client client = ClientProxy.getClient(helloWS); List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = client.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = client.getOutInterceptors(); outInterceptors.add(new AddUserInterceptor("majunpeng", "123456")); outInterceptors.add(new LoggingOutInterceptor()); System.out.println(helloWS.sayHello("jack")); System.out.println("----------------------------------------"); List&lt;User&gt; userLists = helloWS.getUserLists(true); for (User user : userLists) &#123; System.out.println("[ id = " + user.getId() + ",name = " + user.getName() + "]"); &#125; Return userMaps = helloWS.getUserMaps(); List&lt;Entry&gt; entrys = userMaps.getEntry(); for (Iterator&lt;Entry&gt; iterator = entrys.iterator(); iterator.hasNext();) &#123; Entry entry2 = iterator.next(); Integer key = entry2.getKey(); User user = entry2.getValue(); System.out.println("[key="+key+",id="+user.getId()+",name="+user.getName()+"]"); &#125; &#125; 第二种动态调用，不需要生成客户端代码。（一般不会使用） 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws Exception &#123; //动态调用,不需要生成客户端代码 String address = "http://localhost:8080/CXF_Server/webservice/sayHello?wsdl"; JaxWsDynamicClientFactory clientFactory = JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient(address); List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = client.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = client.getOutInterceptors(); outInterceptors.add(new AddUserInterceptor("majunpeng", "123456")); outInterceptors.add(new LoggingOutInterceptor()); //动态调用需要指定接口的命名空间namespaceURI,namespaceURI末尾需要添加“/” QName qName1 = new QName("http://sei.ws.markie.com/", "sayHello"); Object[] obj1 = client.invoke(qName1,"jack"); System.out.println(obj1[0]); System.out.println("@@@@@@@@@@@@@@@@@@@@@@@@@@@"); QName qName2 = new QName("http://sei.ws.markie.com/", "getUserLists"); Boolean flag = true; Object[] obj2 = client.invoke(qName2,flag); for (int i = 0; i &lt; obj2.length; i++) &#123; System.out.println("第" + i + "个：" + obj2[i]); &#125; @SuppressWarnings("unchecked") List&lt;User&gt; users = (List&lt;User&gt;)obj2[0]; for (User user : users) &#123; System.out.println("[id="+ user.getId() +",name="+ user.getName() +"]" + user.isFlag()); &#125; System.out.println("&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;"); QName qName3 = new QName("http://sei.ws.markie.com/", "getUserMaps"); Object[] obj3 = client.invoke(qName3); System.out.println(obj3[0]); Return map = (Return)obj3[0]; List&lt;Entry&gt; entrys = map.getEntry(); for (Iterator&lt;Entry&gt; iterator = entrys.iterator(); iterator.hasNext();) &#123; Entry entry2 = iterator.next(); Integer key = entry2.getKey(); User user = entry2.getValue(); System.out.println("[key="+key+",id="+user.getId()+",name="+user.getName()+"]"); &#125; &#125; 安装CXF步骤1在官网下载cxf的二进制版本的CXF 步骤2解压到任意一个目录下面 步骤3 配置环境变量 新建CXF_HOME = CXF的解压路径（D:\CXF\apache-cxf-3.1.6） 在path中加入% CXF_HOME%\bin; 步骤4在cmd 里面验证CXF是否安装成功 输入命令 wsdl2java -v 如果出现CXF的版本，那么说明安装成功了 。 生成的WSDL文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;xs:element minOccurs="0" name="return" type="xs:string" /&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;/xs:schema&gt; &lt;/wsdl:types&gt; &lt;!--这个message代表输入信息。这个输入信息的类型是sayHello，在&lt;types&gt;中定义过 --&gt; &lt;wsdl:message name="sayHello"&gt; &lt;wsdl:part element="tns:sayHello" name="parameters"&gt;&lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;!--这个message代表输出信息。这个输出信息的类型是sayHelloResponse，在&lt;types&gt;中定义过 --&gt; &lt;wsdl:message name="sayHelloResponse"&gt; &lt;wsdl:part element="tns:sayHelloResponse" name="parameters"&gt; &lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;!--portType 就是我们定义的接口。一个接口对应一个port --&gt; &lt;wsdl:portType name="HelloWorld"&gt; &lt;!--这里的一个operation就是 接口中的一个方法 &lt;wsdl:operation name="sayHello"&gt; &lt;wsdl:input message="tns:sayHello" name="sayHello"&gt; &lt;/wsdl:input&gt; &lt;wsdl:output message="tns:sayHelloResponse" name="sayHelloResponse"&gt; var cpro_psid ="u2572954"; var cpro_pswidth =966; var cpro_psheight =120; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;!--把接口进行 soap 绑定--&gt; &lt;wsdl:binding name="HelloWorldImplServiceSoapBinding" type="tns:HelloWorld"&gt; &lt;!-- 这里指明绑定的协议为 http,style为document--&gt; &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt; &lt;!-- 具体方法的绑定类型定义--&gt; &lt;wsdl:operation name="sayHello"&gt; &lt;soap:operation soapAction="" style="document"/&gt; &lt;wsdl:input name="sayHello"&gt; &lt;!--literal文本 --&gt; s &lt;soap:body use="literal"/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name="sayHelloResponse"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;!--把n个接口放到一起，总称为一个service --&gt; &lt;wsdl:service name="HelloWorldImplService"&gt; &lt;!--这里一个port就是一个接口。对应的绑定刚刚定义过 --&gt; &lt;wsdl:port binding="tns:HelloWorldImplServiceSoapBinding" name="HelloWorldImplPort"&gt; &lt;!--这个接口的地址 --&gt; &lt;soap:address location="http://localhost:8080/HelloWorld" /&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt; &lt;/wsdl:definitions&gt;]]></content>
      <categories>
        <category>WebServcie</category>
      </categories>
      <tags>
        <tag>CXF WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题优化（3）-添加分享]]></title>
    <url>%2F2017%2F05%2F25%2FHexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言 当你看到Damiss的博客，是不是觉得写得很好，想要分享呢，行动起来吧。本篇博客就手把手教你给自己的博客添加分享功能，DaMiss使用的是ShareSDk社会化分享组件 注册ShareSDK账号1.官网地址：http://www.mob.com/ 2.注册登陆成功之后，点击 3.创建自己的应用，应用名称随便写，类型选择web 4.在创建的应用状况里面找到App key 复制下来 添加文件1.找到\themes\next\layout_partials\share，在这个目录下面新建文件sharesdk.swig,并输入一下代码。(注意，早发布之后，可能会出现乱码，你解决办法是你要把这个文件转成utf-8编码即可) 12345678910111213141516171819202122232425262728&lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tencentweibo&quot;&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-weixin&quot;&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-renren&quot;&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-kaixin&quot;&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-pocket&quot;&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-google&quot;&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-youdao&quot;&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-mingdao&quot;&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-pengyou&quot;&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tumblr&quot;&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-instapaper&quot;&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-linkedin&quot;&gt;&lt;p&gt;LinkedIn&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123; theme.shareSDKappkey &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 2.打开\themes\next\layout\post.swig，将以下代码 1234567891011&lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include &apos;_partials/share/baidushare.swig&apos; %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include &apos;_partials/share/add-this.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 替换成： 12345678910111213&lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include &apos;_partials/share/baidushare.swig&apos; %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include &apos;_partials/share/add-this.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include &apos;_partials/share/sharesdk.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 配置主题配置文件新添加代码： 12sharesdk: trueshareSDKappkey: 你的appkey OK ,大功告成，如有疑问，请在评论处留言。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>ShareSDK</tag>
      </tags>
  </entry>
</search>