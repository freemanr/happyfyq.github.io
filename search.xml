<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebService之CXF开发]]></title>
    <url>%2F2017%2F06%2F01%2FWebService%E4%B9%8BCXF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言 Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序从表面上看，Web service 就是一个应用程序，它向外界暴露出一个能够通过Web进行调用的API。这就是说，你能够用编程的方法通过Web来调用这个应用程序。我们把调用这个Web service 的应用程序叫做客户。WebService解决的问题：远程调用，跨平台调用，跨语言调用。 CXF和Axis2都是使用Java编写的WebService技术，不管是使用什么语言编写的webservice都要遵循SOAP协议（简单对象访问协议）， Webservice主要就是两部分组成：SOAP和XML代码片段。 这里DaMiss就说一下CXF的具体实现过程（服务端和客户端） 服务端开发导入jar包导入jar包的时候可以使用maven依赖，前提你这个服务端的开发使用的是maven项目构建工具。 在web.xml里面配置CXF的组件也就是拦截请求，请求哪个路径是使用的webservice技术 12345678&lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 定义服务端的终端接口和它的实现类接口定义【注意】接口定义类上面必须要加标签注释@WebService，在接口方法上面加标签注释@WebMethod 1234567891011@WebServicepublic interface HelloWS &#123; @WebMethod String sayHello(String name); @WebMethod List&lt;User&gt; getUserLists(Boolean flag); @WebMethod Map&lt;Integer,User&gt; getUserMaps();&#125; 接口实现类【注意】指定命名空间targetNamespace（这里的命名空间和自己的包名是有关系的，命名空间采用域名倒置的原则），和服务名字serviceName，指定服务名字的作用是为了在客户端调用的时候，规范代码。 1234@WebService(targetNamespace=Constants.NAMESPACE,serviceName="HelloWSFactory")public class HelloWSImpl implements HelloWS &#123; ..........此处省略实现接口的方法&#125; 发布服务发布服务的有两种方式：①与spring集成②main方法启动方式（web工程是不会用的） 与spring集成发布定义applicationContext-ws.xml文件，文件内容如下 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:lang="http://www.springframework.org/schema/lang" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt;&lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-extension-soap.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt;&lt;!--这里利用bean的配置引入我们的接口实现类 --&gt; &lt;bean id="helloWS" class="com.markie.ws.sei.impl.HelloWSImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt;&lt;!-- 这里的adress就是我们发布的地址，我们在网页上输入网址http：localhost：8080/工程名字/webservice/sayHello?wsdl即可 --&gt; &lt;jaxws:endpoint implementor="#helloWS" address="/sayHello"&gt; &lt;jaxws:inInterceptors&gt; &lt;!-- 系统拦截器 --&gt; &lt;bean class="org.apache.cxf.interceptor.LoggingInInterceptor"/&gt; &lt;!-- 自定义拦截器 --&gt;&lt;!-- &lt;bean class="com.markie.ws.interceptor.CheckUserInterceptor"/&gt; --&gt; &lt;/jaxws:inInterceptors&gt; &lt;jaxws:outInterceptors&gt; &lt;bean class="org.apache.cxf.interceptor.LoggingOutInterceptor"/&gt; &lt;/jaxws:outInterceptors&gt;&lt;/jaxws:endpoint&gt;&lt;/beans&gt; 【注意】上面的步骤当中，我只是了一个接口服务。那么当存在多个接口 的时候，应该怎么做呢？有两种方式供选择。 第一种：两个的服务名个命名空间是一样的，在spring的配置文件里面，分别给这两个接口的实现类加入发布路径，在生成XML文件 的时候分别输入自己的发布路径来获得自己的文件。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:lang="http://www.springframework.org/schema/lang" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt;&lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-extension-soap.xml"/&gt;&lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt;&lt;bean id="helloWS" class="com.markie.ws.sei.impl.HelloWSImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt;&lt;bean id="saygoodWS" class="com.markie.ws.sei.impl.SayGoodByeImpl"&gt; &lt;!-- &lt;property name="userService" ref="userService"/&gt; --&gt;&lt;/bean&gt; &lt;jaxws:server id="sayhelloService" serviceClass="com.markie.ws.sei.impl.HelloWSImpl" address="/sayHello" &gt; &lt;jaxws:serviceBean&gt; &lt;ref bean="helloWS" /&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt; &lt;jaxws:server id="saygoodservice" serviceClass="com.markie.ws.sei.impl.SayGoodByeImpl" address="/sayGoodByeWS" &gt; &lt;jaxws:serviceBean&gt; &lt;ref bean="saygoodWS" /&gt; &lt;/jaxws:serviceBean&gt; &lt;/jaxws:server&gt; &lt;/beans&gt; 第二种：写一个公共的服务接口，其他的在内部service实现，但是在服务端就要告诉客户端有哪些服务名字了。 （我这里先不写具体的步骤了，还没弄多懂） main方法发布 main方法启动（定义发布的网址可以随便写，但是网址后面必须带有在web.xml里面拦截的路径请求字眼，比如我们现在拦截的是/webservice/*，发布成功之后，在网页输入发布网址http://localhost:9999/CXF_Server/webservice/sayHello?wsdl(注意在发布的网址后面追加?wsdl)，即可访问生成的XML代码，这些xml代码片段就是描述了服务端的接口详细信息，是一个XMl文件） 12345678910111213public class PublicServerTest &#123; public static void main(String[] args) &#123; Endpoint endpoint = Endpoint.publish("http://localhost:9999/CXF_Server/webservice/sayHello", new HelloWSImpl()); EndpointImpl endpointImpl = (EndpointImpl) endpoint; List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = endpointImpl.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); //inInterceptors.add(new CheckUserInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = endpointImpl.getOutInterceptors(); outInterceptors.add(new LoggingOutInterceptor()); System.out.println("发布WS服务成功！"); &#125;&#125; 客户端开发下载CXF版本，配置环境变量项目中导入jar包，可以使用maven依赖操作我们在客户端访问发布路径生成的XML文件，这里有两种方式。第一种采用CXF指令，首先建立一个文件切换到此文件夹下面，在终端输入wsdl2java 发布路径？wsdl 即可。也可以把我们访问路径生成的文件拷贝下来，放在新建的文件夹下面（同样执行命令之前要切换到此新建的目录下面），保存在一个后缀名为 .wsdl的文件里面 再在终端输入命令wsdl2java XXX.wsdl即可。执行命令之后会相应的执行命令的文件夹下产生一些一系列的代码，我们把这些代码拷贝都我们的客户工程的一个文件夹下即可。 导入生成的代码之后的应用： 12345678910111213141516171819202122232425262728@Test public void testHello() &#123; //反向生成,通过生成客户端代码实现 URL url = null; //这里的HelloWSFactory 就是我们在服务端生成的XML文件里面的服务名字描述，可以研究一下里面的内容，然后通过getHelloWSImplPort（）方法就可以的到我们的服务端的实现类的对象。就可以使用里面的方法了。 HelloWSFactory helloWSFactory = new HelloWSFactory(url); HelloWS helloWS = helloWSFactory.getHelloWSImplPort(); Client client = ClientProxy.getClient(helloWS); List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = client.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = client.getOutInterceptors(); outInterceptors.add(new AddUserInterceptor("majunpeng", "123456")); outInterceptors.add(new LoggingOutInterceptor()); System.out.println(helloWS.sayHello("jack")); System.out.println("----------------------------------------"); List&lt;User&gt; userLists = helloWS.getUserLists(true); for (User user : userLists) &#123; System.out.println("[ id = " + user.getId() + ",name = " + user.getName() + "]"); &#125; Return userMaps = helloWS.getUserMaps(); List&lt;Entry&gt; entrys = userMaps.getEntry(); for (Iterator&lt;Entry&gt; iterator = entrys.iterator(); iterator.hasNext();) &#123; Entry entry2 = iterator.next(); Integer key = entry2.getKey(); User user = entry2.getValue(); System.out.println("[key="+key+",id="+user.getId()+",name="+user.getName()+"]"); &#125; &#125; 第二种动态调用，不需要生成客户端代码。（一般不会使用） 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws Exception &#123; //动态调用,不需要生成客户端代码 String address = "http://localhost:8080/CXF_Server/webservice/sayHello?wsdl"; JaxWsDynamicClientFactory clientFactory = JaxWsDynamicClientFactory.newInstance(); Client client = clientFactory.createClient(address); List&lt;Interceptor&lt;? extends Message&gt;&gt; inInterceptors = client.getInInterceptors(); inInterceptors.add(new LoggingInInterceptor()); List&lt;Interceptor&lt;? extends Message&gt;&gt; outInterceptors = client.getOutInterceptors(); outInterceptors.add(new AddUserInterceptor("majunpeng", "123456")); outInterceptors.add(new LoggingOutInterceptor()); //动态调用需要指定接口的命名空间namespaceURI,namespaceURI末尾需要添加“/” QName qName1 = new QName("http://sei.ws.markie.com/", "sayHello"); Object[] obj1 = client.invoke(qName1,"jack"); System.out.println(obj1[0]); System.out.println("@@@@@@@@@@@@@@@@@@@@@@@@@@@"); QName qName2 = new QName("http://sei.ws.markie.com/", "getUserLists"); Boolean flag = true; Object[] obj2 = client.invoke(qName2,flag); for (int i = 0; i &lt; obj2.length; i++) &#123; System.out.println("第" + i + "个：" + obj2[i]); &#125; @SuppressWarnings("unchecked") List&lt;User&gt; users = (List&lt;User&gt;)obj2[0]; for (User user : users) &#123; System.out.println("[id="+ user.getId() +",name="+ user.getName() +"]" + user.isFlag()); &#125; System.out.println("&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;"); QName qName3 = new QName("http://sei.ws.markie.com/", "getUserMaps"); Object[] obj3 = client.invoke(qName3); System.out.println(obj3[0]); Return map = (Return)obj3[0]; List&lt;Entry&gt; entrys = map.getEntry(); for (Iterator&lt;Entry&gt; iterator = entrys.iterator(); iterator.hasNext();) &#123; Entry entry2 = iterator.next(); Integer key = entry2.getKey(); User user = entry2.getValue(); System.out.println("[key="+key+",id="+user.getId()+",name="+user.getName()+"]"); &#125; &#125; 安装CXF步骤1在官网下载cxf的二进制版本的CXF 步骤2解压到任意一个目录下面 步骤3 配置环境变量 新建CXF_HOME = CXF的解压路径（D:\CXF\apache-cxf-3.1.6） 在path中加入% CXF_HOME%\bin; 步骤4在cmd 里面验证CXF是否安装成功 输入命令 wsdl2java -v 如果出现CXF的版本，那么说明安装成功了 。 生成的WSDL文件详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &lt;xs:element minOccurs="0" name="return" type="xs:string" /&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;/xs:schema&gt; &lt;/wsdl:types&gt; &lt;!--这个message代表输入信息。这个输入信息的类型是sayHello，在&lt;types&gt;中定义过 --&gt; &lt;wsdl:message name="sayHello"&gt; &lt;wsdl:part element="tns:sayHello" name="parameters"&gt;&lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;!--这个message代表输出信息。这个输出信息的类型是sayHelloResponse，在&lt;types&gt;中定义过 --&gt; &lt;wsdl:message name="sayHelloResponse"&gt; &lt;wsdl:part element="tns:sayHelloResponse" name="parameters"&gt; &lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;!--portType 就是我们定义的接口。一个接口对应一个port --&gt; &lt;wsdl:portType name="HelloWorld"&gt; &lt;!--这里的一个operation就是 接口中的一个方法 &lt;wsdl:operation name="sayHello"&gt; &lt;wsdl:input message="tns:sayHello" name="sayHello"&gt; &lt;/wsdl:input&gt; &lt;wsdl:output message="tns:sayHelloResponse" name="sayHelloResponse"&gt; var cpro_psid ="u2572954"; var cpro_pswidth =966; var cpro_psheight =120; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;!--把接口进行 soap 绑定--&gt; &lt;wsdl:binding name="HelloWorldImplServiceSoapBinding" type="tns:HelloWorld"&gt; &lt;!-- 这里指明绑定的协议为 http,style为document--&gt; &lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt; &lt;!-- 具体方法的绑定类型定义--&gt; &lt;wsdl:operation name="sayHello"&gt; &lt;soap:operation soapAction="" style="document"/&gt; &lt;wsdl:input name="sayHello"&gt; &lt;!--literal文本 --&gt; s &lt;soap:body use="literal"/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name="sayHelloResponse"&gt; &lt;soap:body use="literal"/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;!--把n个接口放到一起，总称为一个service --&gt; &lt;wsdl:service name="HelloWorldImplService"&gt; &lt;!--这里一个port就是一个接口。对应的绑定刚刚定义过 --&gt; &lt;wsdl:port binding="tns:HelloWorldImplServiceSoapBinding" name="HelloWorldImplPort"&gt; &lt;!--这个接口的地址 --&gt; &lt;soap:address location="http://localhost:8080/HelloWorld" /&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt; &lt;/wsdl:definitions&gt;]]></content>
      <categories>
        <category>WebServcie</category>
      </categories>
      <tags>
        <tag>CXF WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之NexT主题优化（3）-添加分享]]></title>
    <url>%2F2017%2F05%2F25%2FHexo%E4%B9%8BNexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96-%E6%B7%BB%E5%8A%A0%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言 当你看到Damiss的博客，是不是觉得写得很好，想要分享呢，行动起来吧。本篇博客就手把手教你给自己的博客添加分享功能，DaMiss使用的是ShareSDk社会化分享组件 注册ShareSDK账号1.官网地址：http://www.mob.com/ 2.注册登陆成功之后，点击 3.创建自己的应用，应用名称随便写，类型选择web 4.在创建的应用状况里面找到App key 复制下来 添加文件1.找到\themes\next\layout_partials\share，在这个目录下面新建文件sharesdk.swig,并输入一下代码。(注意，早发布之后，可能会出现乱码，你解决办法是你要把这个文件转成utf-8编码即可) 12345678910111213141516171819202122232425262728&lt;!--MOB SHARE BEGIN--&gt; &lt;div class=&quot;-mob-share-ui-button -mob-share-open&quot;&gt;分享&lt;/div&gt; &lt;div class=&quot;-mob-share-ui&quot; style=&quot;display: none&quot;&gt; &lt;ul class=&quot;-mob-share-list&quot;&gt; &lt;li class=&quot;-mob-share-weibo&quot;&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tencentweibo&quot;&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qzone&quot;&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-qq&quot;&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-weixin&quot;&gt;&lt;p&gt;微信&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-douban&quot;&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-renren&quot;&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-kaixin&quot;&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-facebook&quot;&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-twitter&quot;&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-pocket&quot;&gt;&lt;p&gt;Pocket&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-google&quot;&gt;&lt;p&gt;Google+&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-youdao&quot;&gt;&lt;p&gt;有道云笔记&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-mingdao&quot;&gt;&lt;p&gt;明道&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-pengyou&quot;&gt;&lt;p&gt;朋友网&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-tumblr&quot;&gt;&lt;p&gt;Tumblr&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-instapaper&quot;&gt;&lt;p&gt;Instapaper&lt;/p&gt;&lt;/li&gt; &lt;li class=&quot;-mob-share-linkedin&quot;&gt;&lt;p&gt;LinkedIn&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;-mob-share-close&quot;&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;-mob-share-ui-bg&quot;&gt;&lt;/div&gt; &lt;script id=&quot;-mob-share&quot; src=&quot;http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123; theme.shareSDKappkey &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;!--MOB SHARE END--&gt; 2.打开\themes\next\layout\post.swig，将以下代码 1234567891011&lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include &apos;_partials/share/baidushare.swig&apos; %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include &apos;_partials/share/add-this.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 替换成： 12345678910111213&lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include &apos;_partials/share/baidushare.swig&apos; %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include &apos;_partials/share/add-this.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include &apos;_partials/share/sharesdk.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; 配置主题配置文件新添加代码： 12sharesdk: trueshareSDKappkey: 你的appkey OK ,大功告成，如有疑问，请在评论处留言。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>ShareSDK</tag>
      </tags>
  </entry>
</search>